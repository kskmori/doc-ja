= OCFリソースエージェント開発者ガイド

== はじめに

本書は、OCF(Open Cluster Framework)準拠のクラスタリソースエージェントに関連するすべての開発者、メンテナおよびコントリビュータのためのガイドとリファレンスです。本書は、リソースエージェントの構造や一般的な機能の説明と、リソースエージェントAPIの説明、リソースエージェント作成者に役に立つヒントやヘルプを提供します。

=== リソースエージェントとは何か？

リソースエージェントとは、クラスタリソースを管理する実行ファイルです。クラスタリソースとは、「クラスタが管理するものはすべてリソースである」という以外に正式な定義はありません。いくつか例を挙げると、IPアドレス、ファイルシステム、データベースサービス、仮想マシン全体など多種多様なものがクラスタリソースになりえます。

=== 誰がまたは何がリソースエージェントを使うのか？

OCF(Open Cluster Framework)に準拠したクラスタ管理アプリケーションが、本書で説明されているリソースエージェントを使ってリソースを管理することができます。本書の執筆時点では、Linuxプラットフォーム用に2つのOCF準拠クラスタ管理アプリケーションがあります。

* _Pacemaker_ ：CorosyncおよびHeartbeatクラスタメッセージングフレームワークの両方をサポートするクラスタマネージャ。Pacemakerは、Linux-HAプロジェクトから進化し独立しています。
* _RGmanager_ ：Red Hat Cluster Suiteでバンドルされているクラスタマネージャ。これは、Corosyncクラスタメッセージングフレームワークだけをサポートします。

=== リソースエージェントはどの言語で記述するのか？

OCF準拠リソースエージェントは _どのような_ プログラミング言語ででも実装可能です。APIは言語を問いません。しかし、ほとんどのリソースエージェントはshellスクリプトとして実装されています。本ガイドは、主にshell言語で記述されたサンプルコードを使います。

=== 名前付け規約はありますか?

あります! リソースエージェントの名称は次の規約に従うという合意があります: リソースエージェントの名前は小文字とし、単語の区切りはダッシュ文字とすること(例: +example-agent-name+)。

既存のエージェントの中にはこの規約に従っているものもそうでないものもありますが、今後作成するエージェントは必ずこのルールに従ったものにするという意図です。

== API定義

=== [[_environment_variables]]環境変数

リソースエージェントは、管理するリソースの設定情報を全て環境変数を通して受け取ります。これらの環境変数の名前は必ず、リソースのパラメタ名に +OCF_RESKEY_+ という接頭語を付加したものになります。たとえば、リソースに +192.168.1.1+ という値が設定された +ip+ というパラメタがある場合、リソースエージェントはこの値を保持している +OCF_RESKEY_ip+ という環境変数にアクセスすることができます。

ユーザによる設定が必須ではないリソースパラメータ(すなわち、リソースエージェントメタデータのパラメータ定義で +required="true"+ が指定されていないパラメータ)に対しては、リソースエージェントは以下を行う必要があります。

* 適切なデフォルト値を提供すること。これはメタデータの中に明記すべきです。慣例として、リソースエージェントでは、+OCF_RESKEY_<parametername>_default+ と名付けられた変数にこのデフォルトを保持するようにします。
* もしくは、未設定の場合に正しく対処すること。

さらに、クラスタマネージャは _meta_ リソースパラメータも使用することがあります。これらはリソース設定が直接適用されるものではなく、クラスタリソースマネージャがリソースを _どのように_ 管理したいかを指定するものです。たとえば、Pacemakerクラスタマネージャは +target-role+ metaパラメータを使って、リソースが起動されるべきか停止されるべきかを指定します。

metaパラメータは +OCF_RESKEY_CRM_meta_+ 名前空間でリソースエージェントに渡されます。（この場合、ハイフンはアンダースコアに変換されます）。したがって、 +target-role+ 属性は +OCF_RESKEY_CRM_meta_target_role+ と名付けられた環境変数にマッピングされます。

その他のシステム環境変数については<<_script_variables,スクリプト変数>>の項に記載しています。

=== アクション

全てのリソースエージェントは必ず1つのコマンドライン引数を取ります。これにはリソースエージェントが実行しようとしているアクションを指定します。以下のアクションは全てのリソースエージェントがサポートしなければなりません。

* +start+ -- リソースを起動します。
* +stop+ -- リソースを停止します。
* +monitor+ -- リソースの状態を問合せします。
* +meta-data+ -- リソースエージェントメタデータをダンプします。

これに加えて、リソースエージェントは以下のアクションをオプションとしてサポートすることもあります。

* +promote+ -- リソースの役割を +Master+ に変更します（Master/Slaveリソースのみ）。
* +demote+ -- リソースの役割を +Slave+ に変更します（Master/Slaveリソースのみ）。
* +migrate_to+ および +migrate_from+ -- リソースのライブマイグレーションを実施します。
* +validate-all+ --リソースの設定を検証します。
* +usage+ or +help+ -- リソースエージェントがクラスタマネージャではなくコマンドラインから起動された場合のため、使用方法を表示します。
* +notify+ -- 他のクローンリソースの状態変化をリソースに通知します。
* +status+ --  +monitor+ に対する歴史的（旧）同義語。

=== タイムアウト

アクションのタイムアウトの処理は、リソースエージェントの範囲の外で実施されます。リソースエージェントアクションがどれぐらいの時間実行されているかを監視し、もし所定の時間内にアクションが終了しない場合にそのアクションを停止するのは、クラスタマネージャの責任です。したがって、リソースエージェント自身は、タイムアウトをチェックする必要はありません。

しかし、実際的なタイムアウト値をリソースエージェントからユーザに_推奨_することはできます(正しく設定すれば、クラスタマネージャによって適切に実行される)。リソースエージェントから、その提案タイムアウト値をどのように提示するかについては<<_metadata,以下のセクション>>を参照してください。

=== [[_metadata]]メタデータ

全てのリソースエージェントは、その目的やサポートしているパラメータを一連の XML メタデータとして記述しなければなりません。このメタデータは、クラスタ管理アプリケーションでオンラインヘルプとして利用されたり、リソースエージェントのmanページをこれから生成したりします。以下は、架空のリソースエージェントにおける一連の架空のメタデータです。

[source,xml]
--------------------------------------------------------------------------
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="foobar">
  <version>0.1</version>
  <longdesc lang="en">
This is a fictitious example resource agent written for the
OCF Resource Agent Developers Guide.
  </longdesc>
  <shortdesc lang="en">Example resource agent 
  for budding OCF RA developers</shortdesc>
  <parameters>
    <parameter name="eggs" unique="0" required="1">
      <longdesc lang="en">
      Number of eggs, an example numeric parameter
      </longdesc>
      <shortdesc lang="en">Number of eggs</shortdesc>
      <content type="integer"/>
    </parameter>
    <parameter name="superfrobnicate" unique="0" required="0">
      <longdesc lang="en">
      Enable superfrobnication, an example boolean parameter
      </longdesc>
      <shortdesc lang="en">Enable superfrobnication</shortdesc>
      <content type="boolean" default="false"/>
    </parameter>
    <parameter name="datadir" unique="0" required="1">
      <longdesc lang="en">
      Data directory, an example string parameter
      </longdesc>
      <shortdesc lang="en">Data directory</shortdesc>
      <content type="string"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"        timeout="20" />
    <action name="stop"         timeout="20" />
    <action name="monitor"      timeout="20"
                                interval="10" depth="0" />
    <action name="notify"       timeout="20" />
    <action name="reload"       timeout="20" />
    <action name="migrate_to"   timeout="20" />
    <action name="migrate_from" timeout="20" />
    <action name="meta-data"    timeout="5" />
    <action name="validate-all"   timeout="20" />
  </actions>
</resource-agent>
--------------------------------------------------------------------------

+resource-agent+ 要素はリソースエージェント毎に必ず1つ記述する必要があり、リソースエージェントの +name+ と +version+ を定義します。

+resource-agent+ の +longdesc+ と +shortdesc+ 要素は、リソースエージェントの機能について長い説明文と短い説明文を記述します。 +shortdesc+ は、そのリソースエージェントが何をするものなのかの一行説明文で、通常簡易な一覧表などで使われます。それに対して +longdesc+ は、リソースエージェントについてできるだけ詳細に説明します。

+parameters+ 要素はリソースエージェントのパラメータについて説明するもので、子供として +parameter+ 要素をリソースエージェントがサポートするパラメータの数だけ持ちます。

それぞれの +parameter+ は、+resource-agent+ 本体と同様に +shortdesc+ と +longdesc+ の記述があり、さらにそのパラメータに期待される内容を説明する +content+ 要素が続きます。

+content+ 要素には、4種類の属性が存在します。

* +type+ はパラメータタイプ（ +string+ , +integer+ , +boolean+ ）を設定します。デフォルト： +string+ 

* +required+ はパラメータ設定が必須（ +required="true"+ ）であるかオプション( +required="false"+ )であるかを設定します。

* オプションパラメータに関しては、+default+ 属性によって適切なデフォルト値を提供することが慣例になっています。

* 最後に、 +unique+ 属性（許容値： +true+ 、 +false+ ）は、この特定のリソースタイプのこのパラメータに対してその指定した値がクラスタ全体で一意となる必要があることを示します。たとえば、高可用フローティングIPアドレスは +unique+ として宣言されています。それは一つのIPアドレスはクラスタ全体で一箇所でのみ実行すべきものであり、重複を避けるためです。

+actions+ のリストは、リソースエージェントがサポートしているアクションを定義します。

それぞれの +action+ は、それぞれ固有の +timeout+ 値を記載します。これは、アクションに対して設定すべき _最小限の_ タイムアウトはいくつか、というヒントをユーザに示しています。これは、ある種のリソース(例: IPアドレスやファイルシステム) では短時間で起動／停止できたり、別のリソース(例: データベース) は数分かかったりする、ということに対応するためです。

さらに、繰り返しアクション（例： +monitor+ ）は、推奨の最小実行間隔 +interval+ も指定する必要があります。 +interval+ は、同じアクションの連続した2回の実行の間隔を指定します。 +timeout+ と同じく、この値のデフォルト設定はできません。つまり、最小実行間隔をどのように設定すればいよいかというヒントをユーザに示しているにすぎません。

== [[_return_codes]]戻り値

リソースエージェントは、アクションの実行に対して必ず定義された戻り値で終了し、アクションの実行結果を呼び出し元に通知しなければなりません。以下の項では戻り値について詳細に説明します。

=== +OCF_SUCCESS+ (0)

アクションは正しく終了しました。これは次の各アクション +start+, +stop+, +promote+, +demote+, +migrate_from+, +migrate_to+, +meta_data+, +help+, +usage+ が成功したときに対する戻り値です。

しかし、+monitor+ (および非推奨の別名 +status+)に対しては少し異なる慣習が適用されます。

* primitive (stateless)リソースに関しては、 +monitor+ からの +OCF_SUCCESS+ は、リソースが実行されていることを意味します。非実行中で正常停止しているリソースに対しては +OCF_NOT_RUNNING+ を返す必要があります。

* master/slave (stateful)リソースに関しては、 +monitor+ からの +OCF_SUCCESS+ は、リソースが _Slaveモードで_ 実行されていることを意味します。Masterモードで実行されているリソースは +OCF_RUNNING_MASTER+ を、正常停止しているリソースは +OCF_NOT_RUNNING+ を返す必要があります。

=== +OCF_ERR_GENERIC+ (1)

アクションは汎用エラーを返しました。リソースエージェントは、以下の項で定義している特定のエラーコードでは問題を正確に表せない場合にのみ、この終了コードを使用すべきです。

クラスタリソースマネージャは、この終了コードを_ソフト_エラーとして解釈します。この場合、特に設定されていない限り、リソースマネージャは +OCF_ERR_GENERIC+ で失敗したところと同じ場所でリカバリしようと試みます。つまり通常は同じノードでリソースが再起動されます。

=== +OCF_ERR_ARGS+ (2)

リソースの設定がこのマシン上では不正です。例えば、ノード上には存在しないパスを参照している場合などです。

NOTE: リソースエージェントは、サポートしていないアクションを実行するよう指示された場合、このエラーを返すべきではありません。その代わり、そのような状況では、OCF_ERR_UNIMPLEMENTEDを返すべきです。

=== +OCF_ERR_UNIMPLEMENTED+ (3)

リソースエージェントは、エージェントに実装されていないアクションを実行するよう指示されました。

リソースエージェントのアクションは全てが必須なわけではありません。+promote+, +demote+, +migrate_to+, +migrate_from+, +notify+ は全て省略可能なアクションであり、リソースエージェントが実装している場合もしていない場合もあります。たとえば、statefulではないリソースを誤って master/slave リソースとして設定してしまった場合、リソースエージェントは +promote+ および +demote+ アクションから +OCF_ERR_UNIMPLEMENTED+ を返却して、ユーザに設定ミスを警告すべきです。

=== +OCF_ERR_PERM+ (4)

アクションは、不十分なアクセス権限により失敗しました。これは、エージェントがあるファイルを開くことができなかった、指定されたソケットでlistenできなかった、ディレクトリに書き込みができなかった、あるいはそれに類する原因によるものです。

クライアントリソースマネージャは、この終了コードを _ハード_エラーとして解釈します。この場合、特に設定されていないかぎり、リソースマネージャは別のノード(アクセス権限に関する問題がないと思われるノード)でリソースを再起動することにより、このエラーで故障したリソースをリカバリしようとします。

=== +OCF_ERR_INSTALLED+ (5)

アクションは、それが実行されたノードに必要コンポーネントがなかったために失敗しました。これには必要なバイナリが実行可能ではなかった、あるいは重要な設定ファイルが読み込めなかった、などがありえます。

クラスタマネージャは、この終了コードを _ハード_ エラーとして解釈します。この場合、特に設定されていないかぎり、リソースマネージャは別のノード（必要ファイルやバイナリがあると思われるノード）でリソースを再起動することによって、このエラーで故障したリソースをリカバリしようとします。

=== +OCF_ERR_CONFIGURED+ (6)

アクションは、ユーザがリソースの設定を誤っていたため失敗しました。たとえば、ユーザが、本来整数を設定すべきパラメータに英数字文字列を設定したような場合です。

クラスタリソースマネージャは、この終了コードを _致命的_ エラーとして解釈します。この設定エラーはクラスタ全体で発生するものであるため、同じノードではもちろんのこと、異なるノードでそのようなリソースをリカバリするのは意味がありません。リソースがこのエラーで故障すると、クラスタマネージャはリソースを停止しようとし、管理者の介入を待ちます。

=== +OCF_NOT_RUNNING+ (7)

リソースは実行されていないと判断しました。これは、 +monitor+ アクションのみによって返される終了コードです。これにはリソースが _正常に_ 終了した場合も、そもそも起動されていなかった場合も含みます。

リソースがエラー状態のせいで実行されていない場合、 +monitor+ アクションは、代わりに +OCF_ERR_+ 終了コードの一つか、 +OCF_FAILED_MASTER+ を返すべきです。

=== +OCF_RUNNING_MASTER+ (8)

リソースは、 +Master+ roleで実行されていると判断しました。これは stateful (Master/Slave)リソースにのみ、そして、その +monitor+ アクションにのみ適用されます。

注意点として、「slaveモードで実行中である」ということを示す特定の終了コードはありません。これは正常実行中の primitive リソースと slave として実行している stateful リソースの間には機能的な違いは何も無いからです。+Slave+ role として正常実行中の stateful リソースは、 +monitor+ アクションに対しては単に +OCF_SUCCESS+ を返すだけで良いです。

=== +OCF_FAILED_MASTER+ (9)

リソースは +Master+ roleで故障していると判断しました。これは stateful (Master/Slave)リソースにのみ、そして、その +monitor+ アクションにのみ適用されます。

クラスタリソースマネージャは、この終了コードを_ソフト_ エラーとして解釈します。この場合、特に設定されていない限り、リソースマネージャは +$OCF_FAILED_MASTER+ で失敗したところと同じ場所でリカバリしようと試みます。つまり通常は同じノードでリソースの降格、停止、起動、昇格が行われます。

== リソースエージェントの構造

典型的な(shellベースの)リソースエージェントは、本項で列挙した順序に従った標準的な構成を持ちます。本項では +foobar+ という名前の架空のリソースエージェントを用いて、実装すべきさまざまなアクションに対してリソースエージェントに期待する動作を記述します。

=== リソースエージェントインタプリタ

スクリプトとして実装されたリソースは、標準の"shebang" (+#!+)ヘッダ構文を使い、そのインタプリタを指定しなければなりません。

--------------------------------------------------------------------------
#!/bin/sh
--------------------------------------------------------------------------

リソースエージェントをshellで記述する場合、一般的には標準shellインタプリタ(+#!/bin/sh+)を指定することが好まれますが、これは必須ではありません。 +/bin/sh+ 互換であると宣言したリソースエージェントでは、特定のshell固有の構文(たとえは +bash+ 固有の +${!variable}+ 構文など)を使用してはいけません。そのようなリソースエージェントに対しては +checkbashisms+ などの清書用ユーティリティを必要に応じて実行することが望ましいです。

既存の +sh+ 互換のリソースエージェントを、 +bash+ や +ksh+、その他一般的ではないshell でしか実行できなくしてしまうパッチはレグレッションバグであるとみなされます。しかし新しいリソースエージェントにおいて、特定のshell、たとえば  +/bin/bash+ をインタプリタとして明確に指定することは全く問題ありません。

=== 著者およびライセンス情報

リソースエージェントは、リソースエージェントの著者や著作権保持者、そして、リソースエージェントに適用されるライセンスを記載したコメントを記述する必要があります。

[source,bash]
--------------------------------------------------------------------------
#
#   Resource Agent for managing foobar resources.
#
#   License:      GNU General Public License (GPL)
#   (c) 2008-2010 John Doe, Jane Roe,
#                 and Linux-HA contributors
--------------------------------------------------------------------------

リソースエージェントが、複数のバージョンが存在するライセンスに当てはまる場合、最新のバージョンが適用されるものとします。

=== [[_initialization]]初期化

すべてのshellリソースエージェントは +ocf-shellfuncs+ 関数ライブラリを読み込むようにします。以下の構文のように +$OCF_FUNCTIONS_DIR+ を通して行います。これはテスト目的やドキュメント生成のためにコマンドラインから上書きできるようにするためです。

[source,bash]
--------------------------------------------------------------------------
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs
--------------------------------------------------------------------------

=== リソースエージェントのアクションを実装する関数

次に続けて、リソースエージェントが提供しているアクションを実装する関数を記述します。個別のアクションの詳細については<<_resource_agent_actions,リソースエージェントのアクション>>で説明します。


=== 実行ブロック

ここは、リソースエージェントが起動されたときに実際に実行される部分です。ここは大体において標準的な構造に従います。

[source,bash]
--------------------------------------------------------------------------
# Make sure meta-data and usage always succeed
case $__OCF_ACTION in
meta-data)	foobar_meta_data
		exit $OCF_SUCCESS
		;;
usage|help)	foobar_usage
		exit $OCF_SUCCESS
		;;
esac

# Anything other than meta-data and usage must pass validation
foobar_validate_all || exit $?

# Translate each action into the appropriate function call
case $__OCF_ACTION in
start)		foobar_start;;
stop)		foobar_stop;;
status|monitor)	foobar_monitor;;
promote)	foobar_promote;;
demote)		foobar_demote;;
notify)		foobar_notify;;
reload)		ocf_log info "Reloading..."
	        foobar_start
		;;
validate-all)	;;
*)		foobar_usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac
rc=$?

# The resource agent may optionally log a debug message
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc
--------------------------------------------------------------------------

== [[_resource_agent_actions]]リソースエージェントのアクション

それぞれのアクションは、リソースエージェントの中で別々の関数もしくはメソッドとして実装するのが一般的です。慣習として、通常は +<agent>_<action>+ という名前をつけます。したがって、+foobar+ の +start+ アクションを実装する関数は +foobar_start()+ という名前にします。

一般論として、リソースエージェントが回復不可能な致命的なエラーに遭遇した場合、即座に終了する、例外を投げる、その他実行を中断することが許されます。この場合の例としては、設定上の問題、バイナリが存在しない、権限の問題、などがあげられます。これらのエラーについては必ずしも呼び出し元にエラーを返してくる必要はありません。

エラーからの復旧動作は、クラスタマネージャがユーザの設定に基づいて適切に実行するべきものです。リソースエージェント側ではその設定についていかなる仮定も持ってはいけません。

=== +start+ アクション

+start+ アクションが起動されたときは、リソースエージェントは(リソースがまだ実行されていない場合は)リソースを起動しなければなりません。つまり、エージェントはリソースの設定を検証し、状態を確認し、リソースが実行されていない場合のみリソースを起動する、ということが必要になります。これらを行うためには、以下の例に示すように、最初に +validate_all+ と +monitor+ を実行するのが一般的な方法です。

[source,bash]
--------------------------------------------------------------------------
foobar_start() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # if resource is already running, bail out early
    if foobar_monitor; then
	ocf_log info "Resource is already running"
	return $OCF_SUCCESS
    fi
    
    # actually start up the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ...

    # After the resource has been started, check whether it started up
    # correctly. If the resource starts asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # start up within the defined timeout, the cluster manager will
    # consider the start action failed
    while ! foobar_monitor; do
	ocf_log debug "Resource has not started yet, waiting"
	sleep 1
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

=== +stop+ アクション

+stop+ アクションが起動されたときは、リソースエージェントは(リソースが実行中の場合は)リソースを停止しなければなりません。つまり、エージェントはリソースの設定を検証し、状態を確認し、リソースがその時点で実行中の場合のみ停止する、ということが必要になります。これらを行うためには、以下の例に示すように、最初に +validate_all+ と +monitor+ を実行するのが一般的な方法です。ここで覚えておくべき重要なことは、+stop+ は強制的な操作であるということです。つまりリソースエージェントは、その権限でできることのすべてを使って(ノードの再起動やシャットダウンまではできないにしても)リソースを停止しなければならないということです。以下の例を見てください。

[source,bash]
--------------------------------------------------------------------------
foobar_stop() {
    local rc

    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    foobar_monitor
    rc=$?
    case "$rc" in
        "$OCF_SUCCESS")
            # Currently running. Normal, expected behavior.
            ocf_log debug "Resource is currently running"
            ;;
        "$OCF_RUNNING_MASTER")
            # Running as a Master. Need to demote before stopping.
            ocf_log info "Resource is currently running as Master"
	    foobar_demote || \
                ocf_log warn "Demote failed, trying to stop anyway"
            ;;
        "$OCF_NOT_RUNNING")
            # Currently not running. Nothing to do.
	    ocf_log info "Resource is already stopped"
	    return $OCF_SUCCESS
            ;;
    esac
    
    # actually shut down the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ...

    # After the resource has been stopped, check whether it shut down
    # correctly. If the resource stops asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # shut down within the defined timeout, the cluster manager will
    # consider the stop action failed
    while foobar_monitor; do
	ocf_log debug "Resource has not stopped yet, waiting"
	sleep 1
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS

}
--------------------------------------------------------------------------

NOTE: stop 操作が成功したときに期待される終了コードは +$OCF_SUCCESS+ です（ +$OCF_NOT_RUNNING+ ではありません）。

IMPORTANT: stop操作が失敗した場合は危険な状況を生み出す可能性があります。この場合クラスタマネージャはほぼ必ずノードを隔離(fencing)することによって問題を解決しようとします。言い換えると、クラスタマネージャは stop 操作が失敗したノードをクラスタから強制的に排除します。この方法は最終的にはデータを保護することに役に立つのですが、アプリケーションやそのユーザに混乱を引き起こします。したがってリソースエージェントは、適切なリソース停止手段をすべて使い果たした場合にのみ、エラー終了とするべきなのです。


=== [[_literal_monitor_literal_action]]+monitor+ アクション

+monitor+ アクションは、リソースのその時点の状態を問合せし、3種類の状態をそれぞれ識別しなければなりません。

* リソースがその時点で実行されています（ +$OCF_SUCCESS+ を返します）
* リソースは正しく停止されています（ +$OCF_NOT_RUNNING+ を返します）
* リソースはエラーに遭遇したため失敗したと認識されます（エラーを示す適切な +$OCF_ERR_+ コードを返します。）

[source,bash]
--------------------------------------------------------------------------
foobar_monitor() {
    local rc

    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    ocf_run frobnicate --test

    # This example assumes the following exit code convention
    # for frobnicate:
    # 0: running, and fully caught up with master
    # 1: gracefully stopped
    # any other: error
    case "$?" in
	0)
            rc=$OCF_SUCCESS
	    ocf_log debug "Resource is running"
            ;;
	1)
            rc=$OCF_NOT_RUNNING
	    ocf_log debug "Resource is not running"
	    ;;
	*)
	    ocf_log err "Resource has failed"
	    exit $OCF_ERR_GENERIC
    esac

    return $rc
}
--------------------------------------------------------------------------

Stateful (master/slave)リソースエージェントは、より高度な監視機構を使い、 +Master+ roleを引き受けるのにどのインスタンスが最適であるかを識別するヒントをクラスタマネージャに提供することができます。
詳細は<<_specifying_a_master_preference,masterプリファレンスを指定する>>で説明されています。

NOTE: クラスタマネージャは、 _probe_ に対して +monitor+ アクションを起動し、リソースがその時点で実行されているかどうかをテストします。通常、monitorオペレーションは、probeおよび「実際の」monitorアクションの間、まったく同じように機能します。しかし、特定のリソースが、probesに対して特別な処理を行う場合、その目的のために +ocf_is_probe+ 簡易関数がOCF shell関数ライブラリで提供されています。

=== +validate-all+ アクション

+validate-all+ アクションは、正しいリソースエージェント設定と作業環境をテストします。 +validate-all+ は、以下のいずれかの戻り値になければなりません。

* +$OCF_SUCCESS+ -- すべてが正しく機能しており、設定も正しく使用可能となっています。
* +$OCF_ERR_CONFIGURED+ -- ユーザはリソースを正しく設定していません。
* +$OCF_ERR_INSTALLED+ -- リソースは正しく設定されているように思われますが、 +validate-all+ が実行されているノードには重要な部分（コンポーネント）がありません。
* +$OCF_ERR_PERM+ -- リソースは正しく設定されており、必要部分（コンポーネント）もすべてありますが、アクセス権限に関するエラー（例：必要ファイルが作成できない）により問題が生じています。 

+validate-all+ は、通常、関数で定義されています。この関数は、対応するアクションが明示的に起動される場合にしか呼び出されませんが、sanityチェックのように、他のほとんどの関数からも呼び出し可能となっています。したがって、リソースエージェントの著者は、関数が +start+ , +stop+ ,および +monitor+ オペレーション中に起動され、また、probes中にも起動されることを考慮しなければなりません。

Probesは、検証にあらたな問題を提議します。probe中（クラスタマネージャが、probe実行ノードでリソースが _起動されていない _と予測する場合）、いくつかの必要部分（コンポーネント）は、影響を受けるノードでは使用不可能となると_予測される_かもしれません。たとえば、これには、probe中の読み込みには提供されないストレージデバイスの共有データが含まれます。したがって +validate-all+ 関数は、 +ocf_is_probe+ 簡易関数を使って、probesを特別に取り扱う必要があります。

[source,bash]
--------------------------------------------------------------------------
foobar_validate_all() {
    # Test for configuration errors first
    if ! ocf_is_decimal $OCF_RESKEY_eggs; then
       ocf_log err "eggs is not numeric!"
       exit $OCF_ERR_CONFIGURED
    fi

    # Test for required binaries
    check_binary frobnicate

    # Check for data directory (this may be on shared storage, so
    # disable this test during probes)
    if ! ocf_is_probe; then
       if ! [ -d $OCF_RESKEY_datadir ]; then
       	  ocf_log err "$OCF_RESKEY_datadir does not exist or is not a directory!"
          exit $OCF_ERR_INSTALLED
       fi
    fi

    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

=== +meta-data+ アクション
+meta-data+ アクションは、リソースエージェントメタデータを標準出力にダンプします。出力は、<<_metadata,メタデータ>>で指定されているようにメタデータフォーマットに準拠する必要があります。

[source,bash]
--------------------------------------------------------------------------
foobar_meta_data {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="foobar">
  <version>0.1</version>
  <longdesc lang="en">
...
EOF
}
--------------------------------------------------------------------------

=== +promote+ アクション

+promote+ アクションはオプショナルとなっています。これは、 _stateful_ リソースエージェントによってのみサポートされなければなりません。このことは、エージェントは +Master+  と +Slave+ という2つの個別の役割（role）を識別しなければならないことを意味します。 +Slave+ は、statelessリソースエージェントでの +Started+ 状態と機能的には同じです。したがって、通常（stateless）のリソースエージェントは、 +start+ および +stop+ のみを実装しなければなりませんが、statefulリソースエージェントは、 +Started+ ( +Slave+ ）および +Master+ の役割（role）の間での遷移を可能にするため、 +promote+ アクションもサポートしなければなりません。

[source,bash]
--------------------------------------------------------------------------
foobar_promote() {
    local rc

    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # test the resource's current state
    foobar_monitor
    rc=$?
    case "$rc" in
        "$OCF_SUCCESS")
            # Running as slave. Normal, expected behavior.
            ocf_log debug "Resource is currently running as Slave"
            ;;
        "$OCF_RUNNING_MASTER")
            # Already a master. Unexpected, but not a problem.
            ocf_log info "Resource is already running as Master"
	    return $OCF_SUCCESS
            ;;
        "$OCF_NOT_RUNNING")
            # Currently not running. Need to start before promoting.
            ocf_log info "Resource is currently not running"
            foobar_start
            ;;
        *)
            # Failed resource. Let the cluster manager recover.
            ocf_log err "Unexpected error, cannot promote"
            exit $rc
            ;;
    esac
    
    # actually promote the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run frobnicate --master-mode || exit $OCF_ERR_GENERIC

    # After the resource has been promoted, check whether the
    # promotion worked. If the resource promotion is asynchronous, the
    # agent may spin on the monitor function here -- if the resource
    # does not assume the Master role within the defined timeout, the
    # cluster manager will consider the promote action failed.
    while true; do
        foobar_monitor
        if [ $? -eq $OCF_RUNNING_MASTER ]; then
            ocf_log debug "Resource promoted"
            break
        else
            ocf_log debug "Resource still awaiting promotion"
            sleep 1
        fi
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

=== +demote+ アクション

+demote+ アクションはオプショナルです。これは、 _stateful_ リソースエージェントによってのみサポートされる必要があります。このことは、エージェントは +Master+  と +Slave+ という2つの個別の役割（role）を識別しなければならないことを意味します。 +Slave+ は、statelessリソースエージェントでの +Started+ 状態と機能的には同じです。したがって、通常（stateless）のリソースエージェントは、 +start+ および +stop+ のみを実装しなければなりませんが、statefulリソースエージェントは、 +Master+ および +Started+ ( +Slave+ )の役割（role）の間での遷移を可能にするため、 +demote+ アクションもサポートしなければなりません。
 
[source,bash]
--------------------------------------------------------------------------
foobar_demote() {
    local rc

    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # test the resource's current state
    foobar_monitor
    rc=$?
    case "$rc" in
        "$OCF_RUNNING_MASTER")
            # Running as master. Normal, expected behavior.
            ocf_log debug "Resource is currently running as Master"
            ;;
        "$OCF_SUCCESS")
            # Alread running as slave. Nothing to do.
            ocf_log debug "Resource is currently running as Slave"
	    return $OCF_SUCCESS
            ;;
        "$OCF_NOT_RUNNING")
            # Currently not running. Getting a demote action
            # in this state is unexpected. Exit with an error
            # and let the cluster manager recover.
            ocf_log err "Resource is currently not running"
            exit $OCF_ERR_GENERIC
            ;;
        *)
            # Failed resource. Let the cluster manager recover.
            ocf_log err "Unexpected error, cannot demote"
            exit $rc
            ;;
    esac
    
    # actually demote the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run frobnicate --unset-master-mode || exit $OCF_ERR_GENERIC

    # After the resource has been demoted, check whether the
    # demotion worked. If the resource demotion is asynchronous, the
    # agent may spin on the monitor function here -- if the resource
    # does not assume the Slave role within the defined timeout, the
    # cluster manager will consider the demote action failed.
    while true; do
        foobar_monitor
        if [ $? -eq $OCF_RUNNING_MASTER ]; then
            ocf_log debug "Resource still awaiting promotion"
            sleep 1
        else
            ocf_log debug "Resource demoted"
            break
        fi
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

=== +migrate_to+ アクション

+migrate_to+ アクションは、2つの目的に対応しています。

* リソースに対してネイティブの _push_ タイプのマイグレーションを起動します。つまり、これは、リソースがその時点で実行されているノードから、特定のノード _に_ 移動するよう指示します。リソースエージェントは、 +$OCF_RESKEY_CRM_meta_migrate_target+ 環境変数を通じて、その宛先を知っています。

* _freeze/thaw_ ( _suspend/resume_ としても知られている)タイプのマイグレーションでリソースをフリーズします。通常、このモードでは、リソースはその時点でのその宛先ノードについての情報を必要としていません。

以下の例は、pushタイプのマイグレーションを示しています。

[source,bash]
--------------------------------------------------------------------------
foobar_migrate_to() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # if resource is not running, bail out early
    if ! foobar_monitor; then
	ocf_log err "Resource is not running"
	exit $OCF_ERR_GENERIC
    fi
    
    # actually start up the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run frobnicate --migrate \
                       --dest=$OCF_RESKEY_CRM_meta_migrate_target \
                       || exit OCF_ERR_GENERIC
    ...

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

対称的に、freeze/thawタイプのマイグレーションは以下のようなfreezeオペレーションを実装します。

[source,bash]
--------------------------------------------------------------------------
foobar_migrate_to() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # if resource is not running, bail out early
    if ! foobar_monitor; then
	ocf_log err "Resource is not running"
	exit $OCF_ERR_GENERIC
    fi
    
    # actually start up the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run frobnicate --freeze || exit OCF_ERR_GENERIC
    ...

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------


=== +migrate_from+ アクション

+migrate_from+ アクションは以下の2つの目的の1つに対応します。

* リソースに対してネイティブの_push_ タイプマイグレーションを完了する。つまり、マイグレーションが正しく終了したかどうかをチェックし、リソースがローカルノードで実行されているかどうかをチェックします。リソースエージェントは、 +$OCF_RESKEY_CRM_meta_migrate_source+ 環境変数を通じて、そのマイグレーションソースを知っています。
* _freeze/thaw_ ( _suspend/resume_ としても知られている)タイプマイグレーションでリソースを解凍する。このモードでは、通常、リソースはその時点でのそのソースノードについての情報を必要としていません。

以下の例は、pushタイプのマイグレーションを示しています。

[source,bash]
--------------------------------------------------------------------------
foobar_migrate_from() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # After the resource has been migrated, check whether it resumed
    # correctly. If the resource starts asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # run within the defined timeout, the cluster manager will
    # consider the migrate_from action failed
    while ! foobar_monitor; do
	ocf_log debug "Resource has not yet migrated, waiting"
	sleep 1
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

対称的に、freeze/thawタイプのマイグレーションは以下のようなthawオペレーションを実装します。

[source,bash]
--------------------------------------------------------------------------
foobar_migrate_from() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # actually start up the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run frobnicate --thaw || exit OCF_ERR_GENERIC

    # After the resource has been migrated, check whether it resumed
    # correctly. If the resource starts asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # run within the defined timeout, the cluster manager will
    # consider the migrate_from action failed
    while ! foobar_monitor; do
	ocf_log debug "Resource has not yet migrated, waiting"
	sleep 1
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

=== [[_literal_notify_literal_action]]+notify+ アクション

通知により、clone（そして、cloneの拡張であるmaster/slaveリソース）のインスタンスは、それらの状態についてお互いに通知します。通知を有効にすると、cloneインスタスのアクションで +pre+ と +post+ が通知されます。そして、クラスタマネージャは、 _すべての_ cloneインスタンスで +notify+ オペレーションを起動します。 +notify+ オペレーションに関しては、追加の環境変数が、リソースエージェント（実行中）に渡されます。

* +$OCF_RESKEY_CRM_meta_notify_type+ --通知タイプ ( +pre+ または +post+ )

* +$OCF_RESKEY_CRM_meta_notify_operation+ -- 通知が説明するオペレーション（アクション） ( +start+ , +stop+ , +promote+ , +demote+ 
など)

* +$OCF_RESKEY_CRM_meta_notify_start_uname+ -- リソースが起動されているノードの名前（ +start+ 通知のみ）

* +$OCF_RESKEY_CRM_meta_notify_stop_uname+ -- リソースが停止されているノードの名前( +stop+ 通知のみ)

* +$OCF_RESKEY_CRM_meta_notify_master_uname+ -- リソースがその時点で _Masterモード_ にある_ノードの名前

* +$OCF_RESKEY_CRM_meta_notify_promote_uname+ -- リソースがその時点でMaster roleにプロモートされているノードの名前 ( +promote+ 通知のみ)

* +$OCF_RESKEY_CRM_meta_notify_demote_uname+ -- ソースがその時点でSlave roleに格下げされているノードの名前 ( +demote+ 通知のみ)

通知は、"pull"スキームを使っているmaster/slaveリソースに特に便利です。この場合、masterはプロバイダであり、slaveはサブスクライバとなります。masterは、プロモートが発生した時にのみ明らかであり、slaveは、正しいプロバイダに彼ら自身を加入するよう設定するために "pre-promote" 通知を使うことができます。同じように、サブスクライバも、プロバイダから脱会したいかもそれません。その場合、それに対して "post-demote" 通知を使うことができます。このコンセプトについては以下の例を参照してください。

[source,bash]
--------------------------------------------------------------------------
foobar_notify() {
    local type_op
    type_op="${OCF_RESKEY_CRM_meta_notify_type}-${OCF_RESKEY_CRM_meta_notify_operation}"

    ocf_log debug "Received $type_op notification."
    case "$type_op" in
	'pre-promote')
	    ocf_run frobnicate --slave-mode \
                               --master=$OCF_RESKEY_CRM_meta_notify_promote_uname \
                               || exit $OCF_ERR_GENERIC
	    ;;
	'post-demote')
	    ocf_run frobnicate --unset-slave-mode || exit $OCF_ERR_GENERIC
	    ;;
    esac

    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

NOTE: master/slaveリソースエージェントは、 _multi-master_ 設定をサポートできます。この場合、常に、複数のmasterが存在します。その場合、 +$OCF_RESKEY_CRM_meta_notify_*_uname+ 変数は、それぞれhostnameのリスト（空白文字で区切られた）を持ちます（例で示されているような1つだけのホスト名でなく）。そのような状況の下で、リソースエージェントは、このリストで正しく繰り返される必要があります。

== [[_script_variables]]スクリプト変数

本項は、リソースエージェントに提供される変数（便利さをもたらす）について説明します。エージェントが実行されている間使用できる他の変数については、
<<_environment_variables,環境変数>>と <<_return_codes,戻り値>>を参照してください。

=== +$OCF_RA_VERSION_MAJOR+

クラスタマネージャが現在使用しているリソースエージェントAPIのメジャーバージョン番号。

=== +$OCF_RA_VERSION_MINOR+

クラスタマネージャが現在使用しているリソースエージェントAPIのマイナーバージョン番号。

=== +$OCF_ROOT+

OCFリソースエージェントのディレクトリ階層のルート。これは、リソースエージェントによって変更されてはいけません。これは、通常 、+/usr/lib/ocf+ となります。

=== +$OCF_FUNCTIONS_DIR+

リソースエージェントshell関数ライブラリ（ +ocf-shellfuncs+ ）が常駐しているディレクトリ。これは、通常、 +$OCF_ROOT+ で定義されており、リソースエージェントによって変更されてはいけません。しかし、この変数は、新規または修正リソースエージェントをテストしている間、コマンドラインから上書きされる場合があります。

=== +$OCF_EXIT_REASON_PREFIX+

リソースエージェントからのエラーメッセージを表示するときに使われるプレフィックス。スクリプト関数はこれを内部的に使うので、シェルベースのスクリプトでは明示的に利用する必要はありません。

=== [[_literal_ocf_resource_instance_literal]]+$OCF_RESOURCE_INSTANCE+

リソースインスタンス名。primitive (non-clone, non-stateful) リソースに関しては、これは単なるリソース名となります。clonesおよびstatefulリソースに対してはこれはprimitive名と、その後にコロンとcloneインスタンス番号（例： +p_foobar:0+ ）が続きます。

=== +$OCF_RESOURCE_TYPE+

現在のリソースのリソース種別。例: IPaddr2。

=== +$OCF_RESOURCE_PROVIDER+

リソースプロバイダ。例: heartbeat。 リソースエージェント API バージョン 1.0 では、クラスタマネージャによっては設定されていないことがあります。

=== +$__OCF_ACTION+ 

その時点で起動されているアクション。これは、クラスタが、リソースエージェントを起動する場合に指定する最初のコマンドライン引数です。

=== +$__SCRIPT_NAME+

リソースエージェントの名前。これは、リソースエージェントスクリプトのベース名です（先行するディレクトリ名が削除された）。

=== +$HA_RSCTMP+

リソースエージェントにより使用される一時ディレクトリです。システム起動シーケンス（LSB準拠Linuxディストリビューション）は、システム起動時、このディレクトリが空にされるようにします。それにより、このディレクトリは、ノードリブートの後、状態データを含まないようになります。

== 簡易関数

=== ロギング： +ocf_log+ 

リソースエージェントは、ロギングに対して +ocf_log+ 関数を使います。この簡易ロギングラッパーは以下のように起動されます。

[source,bash]
--------------------------------------------------------------------------
ocf_log <severity> "Log message
--------------------------------------------------------------------------

これは、以下のseverityをサポートします。

* +debug+ -- デバッギングメッセージ用。ほとんどのロギング設定はデフォルトでこのレベルを抑制します。
* +info+ -- エージェントの行動または状態に関する情報メッセージ。
* +warn+ -- 警告用。これは、回復できないエラーを_生じない_予想外行動を反映するメッセージに対するものです。
* +err+ --エラー用。原則的にこのロギングレベルは、適切なエラーコードでの +exit+ の直前でのみ使われるべきです。
* +crit+ -- クリティカルエラー用。 +err+ でのこのロギングレベルは、リソースエージェントがエラーコードで終了する以外、使われるべきではありません。これはごくまれにしか使われません。

=== バイナリ用テスト： +have_binary+ および +check_binary+ 

リソースエージェントは、特定の実行可能ファイルの使用可能性をテストする必要があります。ここでは +have_binary+ 簡易関数が便利です。

[source,bash]
--------------------------------------------------------------------------
if ! have_binary frobnicate; then
   ocf_log warn "Missing frobnicate binary, frobnication disabled!"
fi
--------------------------------------------------------------------------

バイナリのないことがリソースに対して致命的エラーとなる場合 、+check_binary+ 関数が使われるべきです。

[source,bash]
--------------------------------------------------------------------------
check_binary frobnicate
--------------------------------------------------------------------------

+check_binary+ を使うのは、指定されたバイナリの存在（そして実行可能性）と +$OCF_ERR_INSTALLED+ で終了する（見つからない場合または実行されない場合）をテストする省略メソッドです。

NOTE: テスト用のバイナリがフルパスとして指定されていない場合、 +have_binary+ および +check_binary+ は、両方とも +$PATH+ を使います。バイナリインストレーションパスワードは、ディストリビューションやユーザポリシーによって異なるため、フルパスはテストしないほうがいいでしょう。

=== コマンドを実行し、それらの出力を記録する： +ocf_run+ 

リソースエージェントがコマンドを実行し、その出力を記録する必要がある場合、リソースエージェントは、この例で起動されているように +ocf_run+ 簡易関数を使う必要があります。

[source,bash]
--------------------------------------------------------------------------
ocf_run frobnicate --spam=eggs || exit $OCF_ERR_GENERIC
--------------------------------------------------------------------------

上記に指定したコマンドの場合、リソースエージェントは +frobnicate --spam=eggs+ を実行し、その出力と終了コードを記録します。終了コードが0以外(エラーを示す)の場合、+ocf_run+ はコマンドの出力をログの重要度 +err+ としてログ出力し、その後リソースエージェントは終了します。終了コードが0(成功を示す)の場合、コマンドの出力はログの重要度 +info+ でログ出力します。

コマンド実行が成功したときの出力は無視したい、という場合は、+ocf_run+ の +-q+ オプションが使えます。下記の例では +ocf_run+ はコマンドの終了コードが0以外の場合のみログを出力します。

[source,bash]
--------------------------------------------------------------------------
ocf_run -q frobnicate --spam=eggs || exit $OCF_ERR_GENERIC
--------------------------------------------------------------------------

最後に、リソースエージェントが、ゼロ以外の終了コードのコマンドの出力を、severityが _other_ thanのエラーでログしたい場合は、 +-info+ または +-warn+ オプションを +ocf_run+ に付加して行うことができます。

[source,bash]
--------------------------------------------------------------------------
ocf_run -warn frobnicate --spam=eggs
--------------------------------------------------------------------------

=== ロック： +ocf_take_lock+ および +ocf_release_lock_on_exit+

リソースに関しては、クラスタ設定において同じタイプの異なるリソースがある場合があります。それらは、並列でアクションを実行するべきではありません。同じマシンでアクションが同時実行されないようにするために、リソースエージェントは 、+ocf_take_lock+ および +ocf_release_lock_on_exit+ 簡易関数を使うことができます。

[source,bash]
--------------------------------------------------------------------------
LOCKFILE=${HA_RSCTMP}/foobar
ocf_release_lock_on_exit $LOCKFILE

foobar_start() {
    ...
    ocf_take_lock $LOCKFILE
    ...
}
--------------------------------------------------------------------------

+ocf_take_lock+ は、指定された +$LOCKFILE+ を読み込もうとします。これが不可能な場合 、+ocf_take_lock+ は、0秒から1秒の間、ランダムな時間スリープし、その後、リトライします 。+ocf_release_lock_on_exit+ は、エージェントが終了する場合（なんらかの理由で）、lockfileをリリースします。

=== 数値に対してテストする： +ocf_is_decimal+ 

特にパラメータ検証において、指定された値が数値であるかどうかをテストすると効果的です。そのため に+ocf_is_decimal+ 関数があります。

--------------------------------------------------------------------------
foobar_validate_all() {
    if ! ocf_is_decimal $OCF_RESKEY_eggs; then
        ocf_log err "eggs is not numeric!"
        exit $OCF_ERR_CONFIGURED
    fi
    ...
}
--------------------------------------------------------------------------

=== ブール値に対してテストする： +ocf_is_true+ 

リソースエージェントがbooleanパラメータを定義する場合、そのパラメータに対する値は、 +0+/+1+ 、 +true+/+false+ あるいは +on+ / +off+ としてユーザにより指定されます。しかし、これは、リソースエージェントからの各種のすべての値をテストするには面倒であることから、エージェントは代わり に+ocf_is_true+ 簡易関数を使うべきです。

[source,bash]
--------------------------------------------------------------------------
if ocf_is_true $OCF_RESKEY_superfrobnicate; then
    ocf_run frobnicate --super
fi
--------------------------------------------------------------------------

NOTE:  +ocf_is_true+ が、空の変数あるいは存在しない変数に対して使われると、その関数は、常に、 +1+ の終了コードを返します。これは +false+ と同じです。

=== バージョン比較: +ocf_version_cmp+

リソースエージェントではインストールされているソフトウェアのバージョン番号をチェックしたくなる場合があります。+ocf_version_cmp+ は必要な処理を全て面倒見てくれます。

リターンコードは以下です。

* +0+ -- 一つ目のバージョンは二つ目のバージョンより小さい(早い)
* +1+ -- 二つのバージョンは同一である
* +2+ -- 一つ目のバージョンは二つ目のバージョンより大きい(遅い)
* +3+ -- どちらかの引数がバージョン文字列として認識できなかった

バージョン番号には数字、ドット、ダッシュが含まれることが許されます。

[source,bash]
--------------------------------------------------------------------------
local v=`gooey --version`
ocf_version_cmp "$v" 12.0.8-1
case $? in
	0) ocf_log err "we do not support version $v, it is too old"
	   exit $OCF_ERR_INSTALLED
	;;
	[12]) ;; # we can work with versions >= 12.0.8-1
	3) ocf_log err "gooey produced version <$v>, too funky for me"
	   exit $OCF_ERR_INSTALLED
	;;
esac
--------------------------------------------------------------------------

=== 疑似リソース： +ha_pseudo_resource+ 

「疑似リソース」というのは、リソースエージェントが、実際には、startしたりstopしたりしない実行可能プロセスに類似したもので、単一のアクションを実行するだけのものであり、したがって、アクションが実行されたかどうかを追跡する何らかのフォームが必要となります。 +portblock+ リソースエージェントがこの例です。疑似リソースに対するリソースエージェントは +ha_pseudo_resource+ 簡易関数を使います。この簡易関数はリソースの状態を記録する _tracking files_ を使います。 +foobar+ が疑似リソースを管理するよう構築されている場合、その +start+ アクションは以下のようになります。

[source,bash]
--------------------------------------------------------------------------
foobar_start() {
    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    # if resource is already running, bail out early
    if foobar_monitor; then
	ocf_log info "Resource is already running"
	return $OCF_SUCCESS
    fi

    # start the pseudo resource
    ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} start

    # After the resource has been started, check whether it started up
    # correctly. If the resource starts asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # start up within the defined timeout, the cluster manager will
    # consider the start action failed
    while ! foobar_monitor; do
	ocf_log debug "Resource has not started yet, waiting"
	sleep 1
    done

    # only return $OCF_SUCCESS if _everything_ succeeded as expected
    return $OCF_SUCCESS
}
--------------------------------------------------------------------------

== 慣習

この章では、長年続くリソースエージェントのリポジトリの中から発生した慣習をまとめて記載しています。リソースエージェントの作成者はこれらの慣習に必ずしも従う必要はありませんが、https://ja.wikipedia.org/wiki/%E9%A9%9A%E3%81%8D%E6%9C%80%E5%B0%8F%E3%81%AE%E5%8E%9F%E5%89%87[驚き最小の原則]に則り従った方が良いです。慣習に従ったリソースエージェントの方がより理解しやすく、レビューもしやすくなります。

=== よく利用されるパラメータ名

パラメータ名の中にはすでにいくつものリソースエージェントで利用されているものがあります。新規にリソースエージェントを作成するときは以下の例にならうのが一般的に良い考えです。

* +binary+ -- サーバのデーモンなど、リソースを主に管理するバイナリ名
* +config+ -- 設定ファイルのフルパス名
* +pid+ -- プロセスID(PID)を保持するファイルのフルパス名
* +log+ -- ログファイルのフルパス名
* +socket+ -- リソースが管理する UNIX ソケットのフルパス名
* +ip+ -- デーモンが使用する IP アドレス
* +port+ -- デーモンが使用する TCP または UDP ポート番号

言うまでもなく、これらのうち実際に使用する意味のあるもののみをリソースエージェントに実装すべきです。

=== パラメータのデフォルト値

リソースエージェントパラメータのデフォルトは、 +_default+ 接尾語のついた変数を初期化して設定するようにします。

[source,bash]
--------------------------------------------------------------------------
# Defaults
OCF_RESKEY_superfrobnicate_default=0

: ${OCF_RESKEY_superfrobnicate=${OCF_RESKEY_superfrobnicate_default}}
--------------------------------------------------------------------------

NOTE: リソースエージェントは、メタデータで +required+ と指定されていないパラメータに対してデフォルトを設定しなければなりません。

=== バイナリには +PATH+ を反映する

リソースエージェントでバイナリ名を設定するためのパラメータ(デーモンや監視処理のためのクライアントコマンドなど)を設けたい場合、そのパラメータは +PATH+ 環境変数を反映する方が良いです。フルパスを与えるべきではありません。したがって、以下の方法

[source,bash]
--------------------------------------------------------------------------
# 良い例 -- こうすべき
OCF_RESKEY_frobnicate_default="frobnicate"
: ${OCF_RESKEY_frobnicate="${OCF_RESKEY_frobnicate_default}"}
--------------------------------------------------------------------------

は、フルパスを指定した以下の例よりもより望ましい方法です。

[source,bash]
--------------------------------------------------------------------------
# 悪い例 -- できれば避ける
OCF_RESKEY_frobnicate_default="/usr/local/sbin/frobnicate"
: ${OCF_RESKEY_frobnicate="${OCF_RESKEY_frobnicate_default}"}
--------------------------------------------------------------------------

このルールはデフォルト値に対しても当てはまります。



== 特記事項

=== ライセンス

リソースエージェント寄稿者は、新規リソースエージェントには、GNU General Public License (GPL)（バージョン2以降）を使用してください。shell関数ライブラリは、これについては強制はしていませんが、GNU General Public License (GPL)（バージョン2以降）でライセンスされています（それによりnon-GPLエージェントにより使用されます）。リソースエージェントは、自分自身のライセンスをエージェントソースコードで明示的に_記述しなければなりません_。

=== ロケール設定

<<_initialization,初期化>>で説明されているよう に+ocf-shellfuncs+ を読み込む場合、リソースエージェントの、+LANG+ および +LC_ALL+ は自動的に +C+ ロケールに設定されます。それにより、リソースエージェントは、常に、 +C+ ロケールで機能すると期待でき 、+LANG+ やいずれの +LC_+ 環境変数自体をリセットする必要がありません。


=== 実行中プロセスに対してテストする

特定のプロセス（既知のプロセスIDを持った）がその時点で実行されているかどうかをテストするのによく用いられる方法は、それに +0+ シグナルを送り、エラーをキャッチすることです。以下に類似した方法が示されています。

[source,bash]
--------------------------------------------------------------------------
if kill -s 0 `cat $daemon_pid_file`; then
    ocf_log debug "Process is currently running"
else
    ocf_log warn "Process is dead, removing pid file"
    rm -f $daemon_pid_file
if
--------------------------------------------------------------------------

IMPORTANT: この例よりもより優れた方法として、クライアントプロセスからデーモンに接続して _機能_ をテストする方法があります。<<_literal_monitor_literal_action,+monitor+>>アクションで例を示しています。

=== [[_specifying_a_master_preference]]masterプリファレンスを指定する

Stateful (master/slave)リソースはそれら自身の _master プリファレンス_ を設定する必要があります。それにより、それらはクラスタマネージャにヒントを提供できます。これは、 +Master+ roleへプロモートするためのベストインスタンスとなります。

IMPORTANT: 複数のインスタンスが同一の正のmasterプリファレンスを持つことができます。この場合、クラスタリソースマネージャは、プロモートするリソースエージェントを自動的に選択します。しかし、 _すべての_ インスタンスが（デフォルト）masterスコア（0）を持っている場合、クラスタマネージャは、どのインスタンスをもプロモートしません。 したがって、少なくとも1つのインスタンスが正のmasterスコアを持っていなければなりません。

これに対しては、 +crm_master+ が効果的です。 +crm_attribute+ の簡易ラッパーは、master-<<_literal_ocf_resource_instance_literal,$OCF_RESOURCE_INSTANCE>>と名前が付けられたノード属性を設定し（それが実行されているノードに対して）、指定された値をこの属性に設定します。そして、クラスタマネージャは、対応するインスタンスに対して、これをプロモートスコアに変換します。

Statefulリソースエージェントは、通常、 <<_literal_monitor_literal_action,+monitor+>>や<<_literal_notify_literal_action,+notify+>>アクション中に +crm_master+ を実行します。以下の例では、 +foobar+ リソースエージェントは、アプリケーションの状態をテストすることができます。これは、以下のいずれかに基づいた特定の終了コードを返すバイナリを実行することにより行われます。

* リソースがmaster roleかslave（masterに完全に追いついた；いずれにしても最新データを持っている）であるかどうか
* リソースがslave role（しかし、なんらかの非同期複製がmasterより「遅れている」）であるかどうか
* リソースが正しく停止されているかどうか
* リソースが予期しないで故障したかどうか


[source,bash]
--------------------------------------------------------------------------
foobar_monitor() {
    local rc

    # exit immediately if configuration is not valid
    foobar_validate_all || exit $?

    ocf_run frobnicate --test

    # This example assumes the following exit code convention
    # for frobnicate:
    # 0: running, and fully caught up with master
    # 1: gracefully stopped
    # 2: running, but lagging behind master
    # any other: error
    case "$?" in
	0)
            rc=$OCF_SUCCESS
	    ocf_log debug "Resource is running"
            # Set a high master preference. The current master
            # will always get this, plus 1. Any current slaves
            # will get a high preference so that if the master
            # fails, they are next in line to take over.
            crm_master -l reboot -v 100
            ;;
	1)
            rc=$OCF_NOT_RUNNING
	    ocf_log debug "Resource is not running"
            # Remove the master preference for this node
            crm_master -l reboot -D
	    ;;
        2)
            rc=$OCF_SUCCESS
            ocf_log debug "Resource is lagging behind master"
            # Set a low master preference: if the master fails
            # right now, and there is another slave that does
            # not lag behind the master, its higher master
            # preference will win and that slave will become
            # the new master
            crm_master -l reboot -v 5
            ;;
	*)
	    ocf_log err "Resource has failed"
	    exit $OCF_ERR_GENERIC
    esac

    return $rc
}
--------------------------------------------------------------------------


== リソースエージェントをテストする

本項では、リソースエージェントの自動テスト方法について説明します。テストは開発における重要な要素です。リソースエージェントを新規に作成する場合、既存のリソースエージェントを修正する場合、どちらに対しても重要です。

=== +ocf-tester+ を用いたテスト

リソースエージェントリポジトリ（したがって、インストールされたいずれのリソースエージェントパッケージ）は、 +ocf-tester+ と名付けられたユーティリティを含んでいます。このshellスクリプトは、リソースエージェントの機能を効率的に簡単にテストできるようにします。通常、 +ocf-tester+ は、以下で示されているように +root+ として起動されます。

--------------------------------------------------------------------------
ocf-tester -n <name> [-o <param>=<value> ... ] <resource agent>
--------------------------------------------------------------------------

* +<name>+ は、任意のリソース名です。

* +<param>=<value>+ は、 +-o+ オプションで、テスト用に設定したいリソースパラメータに応じていくつでも設定できます。

* +<resource agent>+ がリソースエージェントへの完全パスです。

+ocf-tester+ は、起動されると、すべての必須アクションを実行し、<<_resource_agent_actions,リソースエージェントアクション>>で説明されているようにアクションを強制実行します。

また、これは、オプショナルのアクションもテストします。オプショナルアクションは、宣伝された時、期待通りに実行される必要がありますが、実装されていない場合には、 +ocf-tester+ がエラーを示さないようにします。

IMPORTANT: +ocf-tester+ はアクションの「ドライラン」を起動しませんし、いかなる種類のリソースダミーをも作成しません。そのかわり、これは、実際のリソースエージェントをそのまま実行します。この場合、それが、データベースのオープンやクローズ、ファイルシステムの実装、仮想マシンの起動や停止などを含んでいても、そのまま実行します。この場合、これは注意して使用しなければなりません。たとえば、以下のように、 +foobar+ リソースデータベースで +ocf-tester+ を実行することができます。

--------------------------------------------------------------------------
# ocf-tester -n foobartest \
             -o superfrobnicate=true \
             -o datadir=/tmp \
             /home/johndoe/ra-dev/foobar
Beginning tests for /home/johndoe/ra-dev/foobar...
* Your agent does not support the notify action (optional)
* Your agent does not support the reload action (optional)
/home/johndoe/ra-dev/foobar passed all tests
--------------------------------------------------------------------------

リソースエージェントの振る舞いがよく把握できない動作をした場合、開発したばかりのソフトウェアではたいていそうなりますが、+-v+ オプションや +-d+ オプションを使ってより多くの出力を出すことができます。これだけではよくわからない場合、+ocf-tester+ に +-X+ を与えることでリソースエージェントのトレースを行うことができます(出力をファイルにリダイレクトするのを忘れないこと。あなたが超速で読める人でない限り)。

=== +ocft+ を用いたテスト

+ocft+ はリソースエージェント用のテストツールです。+ocf-tester+ との大きな違いは、+ocft+ では複雑なテスト環境の作成を自動化している点です。パッケージのインストールや任意のシェルスクリプト実行も可能です。

==== +ocft+ のコンポーネント

+ocft+ には以下のコンポーネントがあります。

* テストケースジェネレータ (+/usr/sbin/ocft+) -- テストケース設定ファイルからシェルスクリプトを生成する

* 設定ファイル (+/usr/share/resource-agents/ocft/configs/+) -- あるリソースエージェントに対する環境設定とテストケースを含む設定ファイル

* テスト用スクリプトが格納される +/var/lib/resource-agents/ocft/cases/+ 、ただし通常この内容を知る必要はありません。

==== テスト環境のカスタマイズ

+ocft+ はリソースエージェントの実行環境を、環境変数を変更する(OCF で規定されているインタフェースによって)、またはその場限りのシェルスクリプトを実行する(例えばファイルのパーミッションを変更したりファイルシステムを unmount したりなど)によって変更します。

==== テストの実行方法

あなたはテストを実行したいソフトウェア(リソース)についてよく知っている必要があります。全ての必要なシナリオについて、全ての期待する動作条件、期待範囲外の動作条件、それらに対してリソースエージェントが取るべきリアクション、などのスケッチを描きます。そしてこれらの動作条件と期待する動作結果を +ocft+ テストケースとしてコード化する必要があります。+ocft+ の実行は簡単です。

---------------------------------------
# ocft make <RA>
# ocft test <RA>
---------------------------------------

一つ目のコマンドはテストケースに対するスクリプトを生成しており、二つ目のコマンドでそれを実行して結果を確認しています。

==== +ocft+ 設定ファイル構文

4つのトップレベルオプションが存在しており、それぞれに複数のサブオプションが存在します。

===== +CONFIG+ (トップレベルオプション)

このオプションはグローバルであり、全てのテストケースに対して影響を与えます。

  ** +AgentRoot+ (サブオプション)
---------------------------------------
AgentRoot /usr/lib/ocf/resource.d/xxx
---------------------------------------

通常はリソースエージェントの場所は +heartbeat+ プロバイダ配下にあるという前提になっています。テストしたいエージェントがそれ以外のベンダによって配布されている場合 `AgentRoot` を設定します。

  ** +InstallPackage+ (サブオプション)
---------------------------------------
InstallPackage package [package2 [...]]
---------------------------------------

テストに必要なパッケージをインストールします。必要なパッケージがすでにインストールされている場合はスキップします。

  ** 'HangTimeout' (サブオプション)
---------------------------------------
HangTimeout secs
---------------------------------------

一回の RA 実行に許される最大時間です。この時間を超過した場合、実行は失敗したとみなされます。

===== +SETUP-AGENT+ (トップレベルオプション)
---------------------------------------
SETUP-AGENT
  bash commands
---------------------------------------

RAのテスト実行前に初期化が必要な場合、そのための bash コードをここに書くことができます。初期化は実行は一回のみです。もし再度初期化の実行が必要な場合は、+/tmp/.[AGENT_NAME]_set+ スタンプファイルを削除してください。

===== +CASE+ (トップレベルオプション)
---------------------------------------
CASE "description"
---------------------------------------

これがテストスイートのメインの構成要素です。一つのテストケースを一つの +CASE+ トップレベルオプションとして記述します。

一つのテストケースは通常複数のサブオプションで構成され、その後に +RunAgent+ サブオプションが続きます。

  ** +Var+ (サブオプション)
---------------------------------------
Var VARIABLE=value
---------------------------------------

リソースエージェントの環境変数を設定します。通常は OCF_RESKEY_xxx を設定します。一点注意点として、"=" の両サイドには空白を入れないでください。

  ** +Unvar+ (サブオプション)
---------------------------------------
Unvar VARIABLE [VARIABLE2 [...]]
---------------------------------------

環境変数を削除します。

  ** +Include+ (サブオプション)
---------------------------------------
Include macro_name
---------------------------------------

'macro_name' の文をインクルードします。以下の +CASE-BLOCK+ の説明を参照してください。

** +Bash+ (サブオプション)
---------------------------------------
Bash bash_codes
---------------------------------------

このオプションは OS の環境を設定するために使用します。ここに BASH のコードを挿入することでシステムを如何様にでもカスタマイズできます。システムが復旧不可能となる結果を引き起こさないように注意してください。

** +BashAtExit+ (サブオプション)
---------------------------------------
BashAtExit bash_codes
---------------------------------------

このオプションは、次のテストケースを正常に実行できるように OS 環境を復旧させるために使用します。もちろん 'Bash' オプションを復旧のために使用することもできます。しかし、もし処理中になんらかの間違いが発生した場合、スクリプトは復旧用のコードを実行せずすぐに終了してしまいます。このような場合は、終了前にシステム環境を復旧させることができる BashAtExit を使用すべきです。

** +RunAgent+ (サブオプション)
---------------------------------------
RunAgent cmd [ret_value]
---------------------------------------

このオプションはリソースエージェントを実行します。"cmd" は、start, status, stop... などのリソースエージェントのパラメータです。二つ目のパラメータは省略可能です。指定することで、リソースエージェントの実行時に実際の返却値と期待する返却値を比較することができるようになります。もし異なっていればバグが見つかったということです。

また、サブオプションをローカルではなくリモートホストで実行することも可能です。プロトコルには ssh が使用され、コマンドはバックグラインドで実行されます。サブオプション名に +@<ipaddr>+ 接尾辞を付与するだけです。例えば、

---------------------------------------
Bash@192.168.1.100 date
---------------------------------------

は、date コマンドを実行します。リモートコマンドはバックグラウンドで実行されます。

要注意: ssh による自動化は、事前に環境を知ることができないためできるとは限りません。"node2" のような「よく利用される」ホスト名を使用すればよいかも? またコマンドはバックグラウンドで実行されるため、終了コードがチェックできるかも不明です。最後に、Var@node には意味があるのか? あるいは現在の環境を何らかの方法でリモートへコピーする? おそらくここには実例が必要でしょう。

全般的に実例が必要です。

===== +CASE-BLOCK+ (トップレベルオプション)
---------------------------------------
CASE-BLOCK macro_name
---------------------------------------

+CASE-BLOCK+ オプションは、 +CASE+ から +Include+ されるマクロを定義します。+CASE+ の全てのサブオプションが +CASE-BLOCK+ で利用可能です。


== リソースエージェントをインストール、パッケージングする

本項では、リソースエージェントの作成とテストが終わった後何をすべきか、つまりどこにインストールして、どのようにあなた独自のアプリケーションパッケージもしくは Linux-HA リソースエージェントリポジトリに含めるのか、について説明します。

=== リソースエージェントをインストールする

リソースエージェントを自分自身のプロジェクトに含めたい場合、正しい場所にそれをインストールしてください。リソースエージェントは、 +/usr/lib/ocf/resource.d/<provider>+ ディレクトリにインストールにインストールしてください。この場合、 +<provider>+ はプロジェクトの名前、または、リソースエージェントを識別したいなんらかの名前を入れてください。

たとえば、 +foobar+ リソースエージェントが、 +fortytwo+ という名前のプロジェクトの一部としてパッケージされている場合、そのリソースエージェントへの正しい完全パスは +/usr/lib/ocf/resource.d/fortytwo/foobar+ となります。この場合、リソースエージェントは、 +0755+ ( +-rwxr-xr-x+ )アクセス権限ビットでインストールしてください。

この方法でインストールを行うと、 OCF準拠クラスタリソースマネージャは、リソースエージェントを正しく識別し、パースし、実行できるようになります。たとえば、Pacemakerクラスタマネージャは、上記のインストレーションパスを +ocf:fortytwo:foobar+ リソースタイプ識別子にマッピングします。

=== リソースエージェントをパッケージする

パッケージリソースがプロジェクトの一部としてパッケージする場合、本項で説明されている注意事項に従ってください。

NOTE: 代わりにリソースエージェントを Linux-HAリソースエージェントリポジトリに提出したい場合、その詳細については <<_submitting_resource_agents,リソースエージェントを提出する>>を参照してください。

==== [[_rpm_packaging]]RPMパッケージング

OCFリソースエージェントは 、+<toppackage>-resource-agents+ という名前でRPMサブパッケージに入れてください。この場合、パッケージがそのプロバイダディレクトリを所有しており、上位 +resource-agents+ パッケージ（ディレクトリ階層を設定し簡易shell関数を提供する）に依存していることを確認してください。以下にRPM仕様スニペットが示されています。

--------------------------------------------------------------------------
%package resource-agents
Summary: OCF resource agent for Foobar
Group: System Environment/Base
Requires: %{name} = %{version}-%{release}, resource-agents

%description resource-agents
This package contains the OCF-compliant resource agents for Foobar.

%files resource-agents
%defattr(755,root,root,-)
%dir %{_prefix}/lib/ocf/resource.d/fortytwo
%{_prefix}/lib/ocf/resource.d/fortytwo/foobar
--------------------------------------------------------------------------

NOTE: RPM spec ファイルに +%package+ 宣言が記述されている場合、RPMは、それ を+Name+ , +Version+ , +License+ などのトップレベルフィールドを継承するサブパッケージであると認識します。そのようなサブパッケージは、それ自身の名前の前に、トップレベルパッケージの名前を自動的に付加します。したがって、上記のスニペットは +foobar-resource-agents+ (パッケージ +Name+ は +foobar+ であると前提されている)と名前が付けられたサブパッケージを作成します。

==== Debianパッケージング

Debianパッケージに関しては、<<_rpm_packaging,RPMs>>と同じように、リソースエージェントを保持する別のパッケージを作成してください。この場合、これは +cluster-agents+ パッケージに依存します。

NOTE: 本項では +debhelper+ でパッケージングされていると前提します。以下に +debian/control+ スニペットの例が示されています。

--------------------------------------------------------------------------
Package: foobar-cluster-agents
Priority: extra
Architecture: all
Depends: cluster-agents
Description: OCF-compliant resource agents for Foobar
--------------------------------------------------------------------------

ここでは、別の +.install+ ファイルも作成します。 +foobar+ リソースエージェントを +fortytwo+ のサブパッケージとしてインストールする例に従い 、+debian/fortytwo-cluster-agents.install+ ファイルは、以下の内容から構成されます。

--------------------------------------------------------------------------
usr/lib/ocf/resource.d/fortytwo/foobar
--------------------------------------------------------------------------

=== [[_submitting_resource_agents]]リソースエージェントを提出する

リソースエージェントをパッケージにバンドルしないけれども、それを、上位リソースエージェントリポジトリ(https://github.com/ClusterLabs/resource-agents[GitHub 上の ClusterLabs リポジトリ])に提出したい場合、本項で説明されている手順に従ってください。

まず、以下のコマンドで、上位リポジトリのワーキングコピー (Git _clone_) を作成してください。

--------------------------------------------------------------------------
git clone git://github.com/ClusterLabs/resource-agents
--------------------------------------------------------------------------

リソースエージェントを +heartbeat+ サブディレクトリにコピーしてください。

--------------------------------------------------------------------------
cd resource-agents/heartbeat
cp /path/to/your/local/copy/of/foobar .
chmod 0755 foobar
cd ..
--------------------------------------------------------------------------

次に、 +resource-agents/heartbeat+ で +Makefile.am+ ファイルを編集し、新規リソースエージェントを +ocf_SCRIPTS+ リストに追加してください。これにより、エージェントが正しくインストールされるようにします。

最後に +resource-agents/doc/man+ でMakefile.amを開き 、+ocf_heartbeat_<name>.7+ を +man_MANS+ 変数に追加してください。これにより、リソースエージェントのマニュアルページが、そのメタデータから自動的に作成され、そのマニュアルページが正しい場所にインストールされます。

そしてここで、あなたの新しいリソースエージェントと二つの Makefile に行った修正をチェンジセットに追加します。

--------------------------------------------------------------------------
git add heartbeat/foobar
git add heartbeat/Makefile.am
git add doc/man/Makefile.am
git commit
--------------------------------------------------------------------------

コミットメッセージには以下のような分かりやすい説明を記述してください。
--------------------------------------------------------------------------
High: foobar: new resource agent

This new resource agent adds functionality to manage a foobar service.
It supports being configured as a primitive or as a master/slave set,
and also optionally supports superfrobnication.
--------------------------------------------------------------------------

これで、パッチセットはメーリングリストで参照が可能となります。

--------------------------------------------------------------------------
git send-email --to=linux-ha-dev@lists.linux-ha.org
--------------------------------------------------------------------------

+git send-email+ は、手元で行われた修正で上流リポジトリに含まれていないものを全てまとめて、メール用に適切なフォーマットを行い、メーリングリストに投稿します。+git send-email+ を利用する際の詳細な設定については +man git-send-email+ を参照してください。

新規リソースエージェントが、マージできるようになれば、上位開発者は、パッチを上位リポジトリにpushします。この時点で、上位からチェックアウトを更新し、元のパッチセットを削除できます。

--------------------------------------------------------------------------
git reset --hard origin/master
git pull
--------------------------------------------------------------------------

=== リソースエージェントの維持管理

あなたが何かのリソースエージェントの管理を行ったり、コードベースに継続的にコントリビューションを行う場合は、GitHub 上であなた専用の +ClusterLabs/resource-agents+ リポジトリの _フォーク(fork)_ を管理するのが一般的で良い方法です。

このためには以下を行います。

* GitHub のアカウントをまだ持っていない場合は https://github.com/signup[GitHub アカウントを作成する]。
* https://github.com/ClusterLabs/resource-agents[+resource-agents+ リポジトリ]を http://help.github.com/fork-a-repo/[フォーク(Fork)] する。
* あなたの個人用のフォークを手元の作業用コピーとしてクローンする。

リソースエージェントの作業を行う場合、ぜひ「こまめにcommit、頻繁にcommit」を心がけてください。commit は後からいつでも +git rebase -i+ でひとまとめにすることができます。

必要な修正が完了し他の人にレビューして欲しいと思ったら、その修正をあなたの GitHub のフォークにプッシュして、+linux-ha-dev+ メーリングリストに投稿します。

レビューが完了したら、必要な要望を反映しツリーを整理して、そしてプルリクエストを発行します。これには二つの方法があります。

* +git request-pull+ コマンドを使って、あなたの修正をまとめて要約したメールの雛形を作成することができます。これに必要な情報を追加してメーリングリストに送信してください。メールの件名に +[GIT PULL]+ のプレフィックスを付与するのは良い方法です。上流メンテナがメッセージを見つけやすくなります。

* GitHub 上で直接プルリクエストを発行することもできます。GitHub は新しいプルリクエストがあったことを上流メンテナに自動的にメールで通知します。プルリクエストの発行に関する詳細については http://help.github.com/send-pull-requests/[github:help] を参照してください。
